<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="This book provides a comprehensive introduction to cognitive modeling using Bayesian mixed models in Julia.">

<title>3&nbsp; Bounded Variables – Cognitive Models</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./3b_choices.html" rel="next">
<link href="./2_predictors.html" rel="prev">
<link href="./media/cover.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Cognitive Models: Computational Modeling of Cognitive Processes with Bayesian Mixed Models in Julia</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/DominiqueMakowski/CognitiveModels"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <a href="./Cognitive-Models.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./3a_scales.html">Scales and Choices</a></li><li class="breadcrumb-item"><a href="./3a_scales.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Bounded Variables</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      <img src="./media/cover_image.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./1_introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Bayesian Modeling in Julia</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2_predictors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Predictors</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Scales and Choices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./3a_scales.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Bounded Variables</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./3b_choices.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Binary Data and Choices</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Reaction Times</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./4a_rt_descriptive.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Descriptive Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./4b_rt_generative.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Generative Models</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./5_individual.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Individual Differences</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#the-problem-with-linear-models" id="toc-the-problem-with-linear-models" class="nav-link active" data-scroll-target="#the-problem-with-linear-models"><span class="header-section-number">3.1</span> The Problem with Linear Models</a></li>
  <li><a href="#rescaling" id="toc-rescaling" class="nav-link" data-scroll-target="#rescaling"><span class="header-section-number">3.2</span> Rescaling</a></li>
  <li><a href="#modified-beta-distribution" id="toc-modified-beta-distribution" class="nav-link" data-scroll-target="#modified-beta-distribution"><span class="header-section-number">3.3</span> Modified Beta Distribution</a></li>
  <li><a href="#beta-models" id="toc-beta-models" class="nav-link" data-scroll-target="#beta-models"><span class="header-section-number">3.4</span> Beta Models</a></li>
  <li><a href="#excluding-extreme-observations" id="toc-excluding-extreme-observations" class="nav-link" data-scroll-target="#excluding-extreme-observations"><span class="header-section-number">3.5</span> Excluding Extreme Observations</a>
  <ul class="collapse">
  <li><a href="#logit-link-for-mu-mu" id="toc-logit-link-for-mu-mu" class="nav-link" data-scroll-target="#logit-link-for-mu-mu"><span class="header-section-number">3.5.1</span> Logit Link for <em>Mu</em> <span class="math inline">\(\mu\)</span></a></li>
  <li><a href="#log-link-for-phi-phi" id="toc-log-link-for-phi-phi" class="nav-link" data-scroll-target="#log-link-for-phi-phi"><span class="header-section-number">3.5.2</span> Log Link for <em>Phi</em> <span class="math inline">\(\phi\)</span></a></li>
  <li><a href="#reparametrized-beta-regression" id="toc-reparametrized-beta-regression" class="nav-link" data-scroll-target="#reparametrized-beta-regression"><span class="header-section-number">3.5.3</span> Reparametrized Beta Regression</a></li>
  </ul></li>
  <li><a href="#ordered-beta-models" id="toc-ordered-beta-models" class="nav-link" data-scroll-target="#ordered-beta-models"><span class="header-section-number">3.6</span> Ordered Beta Models</a></li>
  <li><a href="#adding-predictors" id="toc-adding-predictors" class="nav-link" data-scroll-target="#adding-predictors"><span class="header-section-number">3.7</span> Adding Predictors</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./3a_scales.html">Scales and Choices</a></li><li class="breadcrumb-item"><a href="./3a_scales.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Bounded Variables</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Bounded Variables</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><img src="https://img.shields.io/badge/status-WIP-orange.png" class="img-fluid"></p>
<p>While might be tempted to believe that most of the data that we collect in psychological science are true <strong>continuous</strong> variables, this is often not the case. In fact, many variables are <strong>bounded</strong>: there values are delimited by hard bounds. This is typically the case for slider (aka “analog” scakes), dimensions scores (average or sum) from multiple Likert scales, percentages, proportions, etc.</p>
<p>Most psychometric indices are bounded. For instance, the minimum and maximum values for the IQ test (WAIS-IV) are 45-155. It is 0 and 63 for the depression scale BDI-II, 20 and 80 for the STAI.</p>
<p>Despite this fact, we still most often use <strong>linear models</strong> to analyze these data, which is not ideal as it assumes that the dependent variable is continuous and normally distributed.</p>
<section id="the-problem-with-linear-models" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="the-problem-with-linear-models"><span class="header-section-number">3.1</span> The Problem with Linear Models</h2>
<p>Let’s take the data from <span class="citation" data-cites="makowski2023novel">Makowski et al. (<a href="references.html#ref-makowski2023novel" role="doc-biblioref">2023</a>)</span> that contains data from participants that underwent the Mini-IPIP6 personality test and the PID-5 BF questionnaire for “maladaptive” personality. We will focus on the <strong>“Disinhibition”</strong> trait from the PID-5 BF questionnaire. Note that altough it is usually computed as the average of items a 4-point Likert scales <strong>[0-3]</strong>, this study used analog slider scales to obtain more finer-grained scores.</p>
<pre class="{julia}"><code>#| code-fold: false

using Downloads, CSV, DataFrames, Random
using Turing, Distributions, StatsFuns
using GLMakie
using SubjectiveScalesModels

Random.seed!(123)  # For reproducibility

df = CSV.read(Downloads.download("https://raw.githubusercontent.com/DominiqueMakowski/CognitiveModels/main/data/makowski2023.csv"), DataFrame)

# Show 10 first rows
first(df, 10)

# Plot the distribution of "Disinhibition"
hist(df.Disinhibition, normalization=:pdf, color=:darkred, bins=40)</code></pre>
<p>We will then fit a simple Gaussian model (an “intercept-only” linear model) that estimates the mean and the standard deviation of our variable of interest.</p>
<pre class="{julia}"><code>#| code-fold: false
#| output: false

@model function model_Gaussian(y)

    # Priors
    σ ~ truncated(Normal(0, 1); lower=0)  # Strictly positive half normal distribution
    μ ~ Normal(0, 3)

    # Iterate through every observation
    for i in 1:length(y)
        # Likelihood family
        y[i] ~ Normal(μ, σ)
    end
end

# Fit the model with the data
fit_Gaussian = model_Gaussian(df.Disinhibition)
# Sample results using MCMC
chain_Gaussian = sample(fit_Gaussian, NUTS(), 400)</code></pre>
<p>Let see if the model managed to recover the mean and standard deviation of the data:</p>
<pre class="{julia}"><code>println("Mean of the data: $(round(mean(df.Disinhibition); digits=3)) vs. mean from the model: $(round(mean(chain_Gaussian[:μ]); digits=3))")
println("SD of the data: $(round(std(df.Disinhibition); digits=3)) vs. SD from the model: $(round(mean(chain_Gaussian[:σ]); digits=3))")</code></pre>
<p>Impressive! The model managed to almost perfectly recover the mean and standard deviation of the data. <strong>This means we must have a good model, right?</strong> Not so fast!</p>
<p>Linear models are <em>by definition</em> designed at recovering the mean of the outcome variables (and its SD, assuming it is invariant across groups). That does not mean that they can <strong>capture the full complexity of the data</strong>.</p>
<p>Let us then jump straight into generating <strong>predictions</strong> from the model and plotting the results against the actual data to see how well the model fits the data (a procedure called the <strong>posterior predictive check</strong>).</p>
<pre class="{julia}"><code>#| output: false

pred = predict(model_Gaussian([(missing) for i in 1:length(df.Disinhibition)]), chain_Gaussian)
pred = Array(pred)</code></pre>
<pre class="{julia}"><code>fig = hist(df.Disinhibition, normalization=:pdf, color=:darkred, bins=40)
for i in 1:length(chain_Gaussian)
    density!(pred[i, :], color=(:black, 0.0), strokecolor=(:black, 0.1), strokewidth=1)
end
fig</code></pre>
<div class="callout callout-style-default callout-tip callout-titled" title="Code Tip">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Code Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>The plotting functions from the <code>Makie</code> package can take a tuple of a colour and an alpha value (e.g., <code>color=(:red, 0.3)</code>) to set the transparency of the plotted elements.</p>
</div>
</div>
<p>As we can see, the model assumes that the data is normally distributed, in a way that allows for negative values and values above 3, which <strong>are not possible</strong> as our variable is - <strong>by design</strong> - bounded between 0 and 3 (at it is the result of the mean of variables between 0 and 3). The linear model might thus not be the best choice for this type of data.</p>
</section>
<section id="rescaling" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="rescaling"><span class="header-section-number">3.2</span> Rescaling</h2>
<p>Continuous variables can be trivially rescaled, which is often done to improve the interpretability of the results. For instance, a <em>z</em>-score is a rescaled variable with a mean of 0 and a standard deviation of 1 that allows for an interpretation in terms of deviation from the mean. Importantly, rescaling variables does not change the variable’s distribution or the absolute relationship between variables. In other words, it does not alter the fundamental conclusions from an analysis, but can help with the interpretation of the results (or computational performance).</p>
<p>Two common rescaling methods are <strong>standardization</strong> (mean=0, SD=1) and <strong>normalization</strong> (to a 0-1 range). The benefits of standardization are the interpretation in terms of the magnitude of deviation relative to its own sample (which can be compared across variables). The benefits of normalization are the interpretation in terms of <strong>“proportion”</strong> (percentage): a value of <span class="math inline">\(0.5\)</span> (i.e., <span class="math inline">\(50\%\)</span>) means that the value is in the middle of the range. The latter is particularly useful for bounded variables, as it redefines their bounds to 0 and 1 and allows for a more intuitive interpretation (e.g., “Condition B led to an increase of 20% of the rating on that scale”).</p>
<p>Let’s rescale the “Disinhibition” variable to a 0-1 range:</p>
<pre class="{julia}"><code>#| code-fold: false
#| output: false

function data_rescale(x; old_range=[minimum(x), maximum(x)], new_range=[0, 1])
    return (x .- old_range[1]) ./ (old_range[2] - old_range[1]) .* (new_range[2] - new_range[1]) .+ new_range[1]
end

# Rescale the variable
df.Disinhibition2 = data_rescale(df.Disinhibition; old_range=[0, 3], new_range=[0, 1])</code></pre>
<pre class="{julia}"><code># Visualize
fig = hist(df.Disinhibition2, normalization=:pdf, color=:darkred, bins=beta_bins(30))
xlims!(-0.1, 1.1)
fig</code></pre>
<div class="callout callout-style-default callout-tip callout-titled" title="Code Tip">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Code Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>We can use the <code>beta_bins()</code> function from the SubjectiveScaleModels.jl package to create bin edges that work nicely with the Beta distribution.</p>
</div>
</div>
</section>
<section id="modified-beta-distribution" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="modified-beta-distribution"><span class="header-section-number">3.3</span> Modified Beta Distribution</h2>
<p>One good potential alternative to linear models for bounded variables is to use a <strong>Beta distribution</strong> instead of a Gaussian distribution, as the Beta distribution is naturally bounded between 0 and 1 (<strong>not including them</strong>). Moreover, Beta distributions are powerful and can model a wide variety of shapes, including normal-like distributions, but also uniformly spread data and data clustered at one or both ends.</p>
<p>The Beta distribution is typically defined by two parameters, <em>alpha</em> <span class="math inline">\(\alpha\)</span> and <em>beta</em> <span class="math inline">\(\beta\)</span>, which are the shape parameters. Unfortunately, these parameters are not very intuitive, and so we often use a “reparametrization” of the Beta distribution to define it by its mean <em>mu</em> <span class="math inline">\(\mu\)</span> and “precision” <em>phi</em> <span class="math inline">\(\phi\)</span> (referring to the narrowness of the distribution). This is particularly convenient in the context of regressions, as these parameters are more interpretable and can be directly linked to the predictors.</p>
<p>We will use a reparametrization of the Beta distribution based on the mean <em>mu</em> <span class="math inline">\(\mu\)</span> and precision <em>phi</em> <span class="math inline">\(\phi\)</span>, that converts them to the shape parameters <em>alpha</em> <span class="math inline">\(\alpha\)</span> and <em>beta</em> <span class="math inline">\(\beta\)</span>. You can find details about this reparametrization in the documentation of the <a href="https://dominiquemakowski.github.io/SubjectiveScalesModels.jl/dev/BetaPhi2/"><strong>BetaPhi2()</strong></a> function of the <code>SubjectiveScalesModels.jl</code> package.</p>
<p><img src="https://github.com/DominiqueMakowski/SubjectiveScalesModels.jl/blob/main/docs/img/animation_BetaPhi2.gif?raw=true" class="img-fluid"></p>
</section>
<section id="beta-models" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="beta-models"><span class="header-section-number">3.4</span> Beta Models</h2>
<p>Note that we have a suited distribution for our bounded variable, we can now fit a Beta model to the rescaled variable. However, there is one important issue to address: the Beta distribution is not defined at exactly 0 and 1, and we currently rescaled our variable to be between 0 and 1, possibly including them.</p>
<p>One common trick is to actually rescale our variable to be within <span class="math inline">\([0, 1]\)</span> by <strong>nudging</strong> the zeros and ones to be just above and below, respectively. For this, one can use the function <code>eps()</code>, which returns the smallest possible number. For instance, one can rescale the variable to be in the range <code>[eps(), 1 - eps()]</code>, equivalent to <span class="math inline">\([0.000...1, 0.999...]\)</span>.</p>
<pre class="{julia}"><code>#| code-fold: false
#| output: false

df.Disinhibition3 = data_rescale(df.Disinhibition; old_range=[0, 3], new_range=[eps(), 1 - eps()])</code></pre>
<p>For the priors, we will use a Beta distribution <span class="math inline">\(Beta(1.25, 1.25)\)</span> for <em>mu</em> <span class="math inline">\(\mu\)</span> that is naturally bounded at <span class="math inline">\(]0, 1[\)</span>, peaks at 0.5, and assign less plausibility to extreme values. A Gamma distribution <span class="math inline">\(Gamma(1.5, 15)\)</span> for <em>phi</em> <span class="math inline">\(\phi\)</span> is a good choice for the precision, as it is naturally bounded at <span class="math inline">\(]0, +\infty[\)</span>.</p>
<pre class="{julia}"><code>fig = Figure()
ax1 = Axis(fig[1, 1], xlabel="Value of μ", ylabel="Plausibility", title="Prior for μ ~ Beta(1.25, 1.25)", yticksvisible=false, yticklabelsvisible=false,)
band!(ax1, range(0, 1, length=1000), 0, pdf.(Beta(1.25, 1.25), range(0, 1, length=1000)), color=:red)
ylims!(0, 1.25)
ax1 = Axis(fig[1, 2], xlabel="Value of ϕ", title="Prior for ϕ ~ Gamma(1.5, 15)", yticksvisible=false, yticklabelsvisible=false,)
band!(ax1, range(0, 120, length=1000), 0, pdf.(Gamma(1.5, 15), range(0, 120, length=1000)), color=:blue)
fig</code></pre>
<p>We can now fit a Beta model to the rescaled variable.</p>
<pre class="{julia}"><code>#| code-fold: false
#| output: false

@model function model_Beta(y)
    μ ~ Beta(1.25, 1.25)
    ϕ ~ Gamma(1.5, 15)

    for i in 1:length(y)
        y[i] ~ BetaPhi2(μ, ϕ)
    end
end

fit_Beta = model_Beta(df.Disinhibition3)
posteriors_Beta = sample(fit_Beta, NUTS(), 500)</code></pre>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Note that it is actually convenient to express the parameters with constraints such as a specific range or sign (e.g., positive) on <strong>transformed</strong> scales (e.g., the log scale) rather than the original scale. We will demonstrate this better way of parametrizing a model below.</p>
</div>
</div>
<p>Let us see make a posterior predictive check to see how well the model fits the data.</p>
<pre class="{julia}"><code>pred = predict(model_Beta([(missing) for i in 1:nrow(df)]), posteriors_Beta)
pred = Array(pred)

fig = hist(df.Disinhibition3, normalization=:pdf, color=:darkred, bins=beta_bins(30))
for i in 1:length(posteriors_Beta)
    hist!(pred[i, :], normalization=:pdf, bins=beta_bins(30), color=(:black, 0.01))
end
fig</code></pre>
<div class="callout callout-style-default callout-tip callout-titled" title="Code Tip">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Code Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>The distribution of bounded data is typically difficult to visualize. Density plots will tend to be very distorted at the edges (due to the Gaussian kernel used), and histograms will be dependent on the binning. One option is to specify the bin edges in a consistent way (for instance, using <code>beta_bins(30)</code>).</p>
</div>
</div>
<p>As we can see, the model produced a distribution that appears to be collapsed to the left, not reflecting the actual data. The model fit appears <strong>quite terrible</strong>. Why?</p>
</section>
<section id="excluding-extreme-observations" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="excluding-extreme-observations"><span class="header-section-number">3.5</span> Excluding Extreme Observations</h2>
<p>One of the main issues is that, as you can se from the histogram, there is a high number of observations clumped at zero. This is a <strong>very common and often overlooked issue</strong> in psychological science, where participants tend to use the extreme values of the scale (0 and 1) more often than the intermediate values. This creates a <strong>bimodal</strong> distribution which makes standard unimodal distributions fail to capture the data (note this issue is also present with linear models, which estimates will get biased by this configuration away from the actual “mean” of the variable).</p>
<p>One simple, although not ideal, solution could be to <strong>exclude extreme values</strong> (zeros or ones). Beyond the statistical sanitization benefits, one could argue that these “floor” and “ceiling” effects might correspond to a <strong>different cognitive process</strong> (this will be important in the latter part of this chapter).</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>For instance, in the case of a bounded scale type of trials, participants might actually use a dual strategy in order to lower the cognitive load. For each item, they would judge 1) whether their answer is “completely” yes or no (i.e., 0 or 1) and 2) if not, they would then engage in a more nuanced and costly evaluation of the degree (i.e., use continuous values in between).</p>
</div>
</div>
<p>Let’s create a new variable without the extreme values.</p>
<pre class="{julia}"><code>#| code-fold: false
#| output: false

# Filter out extreme values
var_noextreme = df.Disinhibition2[(df.Disinhibition2.&gt;0).&amp;(df.Disinhibition2.&lt;1)]</code></pre>
<section id="logit-link-for-mu-mu" class="level3" data-number="3.5.1">
<h3 data-number="3.5.1" class="anchored" data-anchor-id="logit-link-for-mu-mu"><span class="header-section-number">3.5.1</span> Logit Link for <em>Mu</em> <span class="math inline">\(\mu\)</span></h3>
<p>This time, we will add another trick to make the model more robust (note that this is a general improvement that we are introducing here but that is not related to the current issue at hand of the extreme values). The current parameter <em>mu</em> <span class="math inline">\(\mu\)</span> is defined on the <span class="math inline">\(]0, 1[\)</span> range. Although this is not an issue in our model where we don’t have any predictors, these types of bounded parameters can be a bit problematic in the context of regressions, where the effect of predictors can push the parameter outside of its bounds. For example, imagine that the algorithm pics a value of <span class="math inline">\(0.45\)</span> for <em>mu</em> <span class="math inline">\(\mu\)</span> from the prior, and then picks a value of <span class="math inline">\(+0.30\)</span> for the effect of a potential predictor (e.g., an experimental condition). This would result in a value of <span class="math inline">\(0.75\)</span>, which is outside the range of possible, and would make the model fail to converge.</p>
<p>One common solution (at the heard of the so-called <strong>logistic models</strong>) is to express <em>mu</em> <span class="math inline">\(\mu\)</span> on the logit scale, which transforms from a bounded [0, 1] range it to an unbounded <span class="math inline">\(]-\infty, +\infty[\)</span> range. The priors on <em>mu</em> <span class="math inline">\(\mu\)</span> can then be specified using any unbounded distributions (e.g., <span class="math inline">\(Normal(0, 3)\)</span>), without worrying about the estimates going out of bounds. The parameter is then transformed back to the <span class="math inline">\(]0, 1[\)</span> range using the <strong>logistic</strong> function (available in the <code>StatsFuns</code> package) before being evaluated.</p>
<p>The logistic function is a simple transformation that maps any value from the unbounded range <span class="math inline">\(]-\infty, +\infty[\)</span>) back to the 0, 1 range.</p>
<pre class="{julia}"><code>xaxis = range(-10, 10, length=1000)

fig = Figure()
ax1 = Axis(fig[1:2, 1], xlabel="Value of μ on the logit scale", ylabel="Actual value of μ", title="Logistic function")
lines!(ax1, xaxis, logistic.(xaxis), color=:red, linewidth=2)
ax2 = Axis(fig[1, 2], xlabel="Value of μ on the logit scale", ylabel="Plausibility", title="Prior for μ ~ Normal(0, 3)", yticksvisible=false, yticklabelsvisible=false,)
lines!(ax2, xaxis, pdf.(Normal(0, 3), xaxis), color=:blue, linewidth=2)
ax3 = Axis(fig[2, 2], xlabel="Value of μ after logistic transformation", ylabel="Plausibility", yticksvisible=false, yticklabelsvisible=false,)
lines!(ax3, logistic.(xaxis), pdf.(Normal(0, 3), xaxis), color=:green, linewidth=2)
fig</code></pre>
</section>
<section id="log-link-for-phi-phi" class="level3" data-number="3.5.2">
<h3 data-number="3.5.2" class="anchored" data-anchor-id="log-link-for-phi-phi"><span class="header-section-number">3.5.2</span> Log Link for <em>Phi</em> <span class="math inline">\(\phi\)</span></h3>
<p>Similarly, because precision <em>phi</em> <span class="math inline">\(\phi\)</span> is a positive parameter that can go from 0 to big values, with a particular threshold value at <code>1</code> (where the distribution becomes flat), it is often more convenient to <strong>express it on the log scale</strong> to be able to set priors on effects without worrying about potential combinations of the parameters that would result in negative values of <em>phi</em> <span class="math inline">\(\phi\)</span>, which would make the model fail to converge.</p>
<p>Having the parameter on the log scale simply means that <strong>its value will be exponentiated</strong> before being used in the Beta distribution (the log transformation being the <em>inverse</em> transformation of the exponential function). Expressing <em>phi</em> <span class="math inline">\(\phi\)</span> on the log scale is convenient because we can set a <span class="math inline">\(Normal\)</span> prior centered around zero, which will result (after the exponential transformation) in a distribution peaking at 1 (which is a good prior for the precision parameter).</p>
<p>Importantly, <strong>changing the link function</strong> of parameters does not change the model <em>per se</em>, but it makes it more convenient to set priors and often makes the model more efficient.</p>
<pre class="{julia}"><code>xaxis = range(-10, 10, length=1000)

fig = Figure()
ax1 = Axis(fig[1:2, 1], xlabel="Value of ϕ on the log scale", ylabel="Actual value of ϕ", title="Exponential function")
lines!(ax1, xaxis, exp.(xaxis), color=:red, linewidth=2)
xlims!(-10, 10)
ax2 = Axis(fig[1, 2], xlabel="Value of ϕ on the log scale", ylabel="Plausibility", title="Prior for ϕ ~ Normal(0, 2)", yticksvisible=false, yticklabelsvisible=false,)
lines!(ax2, xaxis, pdf.(Normal(0, 2), xaxis), color=:blue, linewidth=2)
ax3 = Axis(fig[2, 2], xlabel="Value of ϕ after exponential transformation", ylabel="Plausibility", yticksvisible=false, yticklabelsvisible=false,)
lines!(ax3, exp.(xaxis), pdf.(Normal(0, 2), xaxis), color=:green, linewidth=2)
xlims!(-1, 20)
fig</code></pre>
</section>
<section id="reparametrized-beta-regression" class="level3" data-number="3.5.3">
<h3 data-number="3.5.3" class="anchored" data-anchor-id="reparametrized-beta-regression"><span class="header-section-number">3.5.3</span> Reparametrized Beta Regression</h3>
<p>Let us now refit the Beta model using these link functions.</p>
<pre class="{julia}"><code>#| code-fold: false
#| output: false

@model function model_Beta(y)
    μ ~ Normal(0, 3)  # On the logit scale
    ϕ ~ Normal(0, 2)  # On the log scale

    for i in 1:length(y)
        y[i] ~ BetaPhi2(logistic(μ), exp(ϕ))
    end
end

# Refit
fit_Beta = model_Beta(var_noextreme)
posteriors_Beta = sample(fit_Beta, NUTS(), 500)</code></pre>
<p>The only caveat is that we need to <strong>transform the parameters back</strong> to the original scale when interpreting the results.</p>
<pre class="{julia}"><code>params = DataFrame(mean(posteriors_Beta))
params.mean_raw = [logistic(params.mean[1]), exp(params.mean[2])]
params</code></pre>
<p>Let us now make a posterior predictive check to see how well the model fits the data.</p>
<pre class="{julia}"><code>pred = predict(model_Beta([(missing) for i in 1:length(var_noextreme)]), posteriors_Beta)
pred = Array(pred)

fig = hist(var_noextreme, normalization=:pdf, color=:darkred, bins=beta_bins(30))
for i in 1:length(posteriors_Beta)
    hist!(pred[i, :], normalization=:pdf, bins=beta_bins(30), color=(:black, 0.01))
end
fig</code></pre>
<p>Although removing the extreme values did improve the fit, it is not a perfect solution, as it neglects the importance of these values and the potential cognitive processes behind them.</p>
</section>
</section>
<section id="ordered-beta-models" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="ordered-beta-models"><span class="header-section-number">3.6</span> Ordered Beta Models</h2>
<p>The problem of clustered values at zero and one is a common and known issue, and several solutions have been proposed to address it. One of the most popular involves a specific model called <strong>Zero and One Inflated Beta Regression (ZOIB)</strong>, that separately models the probability of a value being zero or one, and then models the distribution of the values in between. An alternative has been recently introduced by <span class="citation" data-cites="kubinec2023ordered">Kubinec (<a href="references.html#ref-kubinec2023ordered" role="doc-biblioref">2023</a>)</span>, named <strong>Ordered Beta Regression</strong>, that is more parsimonious and easier to interpret.</p>
<p>The Ordered Beta distribution is a Beta distribution (that describes values in between zero and one) that additionally defines <strong>lower and upper “cut points”</strong> parameters, <em>k0</em> and <em>k1</em>, respectively. These cut points represents the thresholds beyond which the probability of the variable being zero or one increases. In psychological terms, they might be seen as (virtual) points usually near the extremes of the scale, by which participants might consider their response to be equivalent to zero or one (i.e., at the edges of the scale).</p>
<p><img src="https://github.com/DominiqueMakowski/SubjectiveScalesModels.jl/raw/main/docs/img/animation_OrderedBeta.gif?raw=true" class="img-fluid"></p>
<p>We will use the priors <a href="https://dominiquemakowski.github.io/SubjectiveScalesModels.jl/dev/OrderedBeta/">recommended</a> in the <code>SubjectiveScalesModels.jl</code> package <strong>(ADD REF)</strong>.</p>
<pre class="{julia}"><code>#| code-fold: false
#| output: false

@model function model_OrderedBeta(y)
    # Priors
    μ ~ Normal(0, 1)
    ϕ ~ Normal(0, 1)
    k0 ~ -Gamma(3, 3)
    k1 ~ Gamma(3, 3)

    # Model
    for i in 1:length(y)
        y[i] ~ OrderedBeta(logistic(μ), exp(ϕ), logistic(k0), logistic(k1))
    end
end

# Refit
fit_OrderedBeta = model_OrderedBeta(df.Disinhibition2)
posteriors_OrderedBeta = sample(fit_OrderedBeta, NUTS(), 500)</code></pre>
<pre class="{julia}"><code>pred = predict(model_OrderedBeta([(missing) for i in 1:length(df.Disinhibition2)]), posteriors_OrderedBeta)
pred = Array(pred)

fig = hist(df.Disinhibition2, normalization=:pdf, color=:darkred, bins=beta_bins(30))
for i in 1:length(posteriors_OrderedBeta)
    hist!(pred[i, :], normalization=:pdf, bins=beta_bins(30), color=(:black, 0.01))
end
fig</code></pre>
<p>As we can see, the model very nicely captures the distribution of the data, including the high density of the (only) extreme response (i.e., zeros). In conclusion, Ordered Beta models are very powerful and flexible to describe data with natural bounds, common in psychological science.</p>
</section>
<section id="adding-predictors" class="level2" data-number="3.7">
<h2 data-number="3.7" class="anchored" data-anchor-id="adding-predictors"><span class="header-section-number">3.7</span> Adding Predictors</h2>
<p>In the following example, we are going to test the effect of <strong>Conscientiousness</strong> on <strong>Disinhibition</strong> (i.e., the relationship between these two personality traits). However, unlike standard linear models that would only estimate the effect of Conscientiousness on the mean of Disinhibition, we will use an Ordered Beta model to estimate the effect of Conscientiousness on <strong>all the parameters</strong>*, namely the mean, precision, and cut points.</p>
<pre class="{julia}"><code>#| code-fold: false

describe(df.Conscientiousness)</code></pre>
<p>Conscientiousness is a continuous variable ranging from ~1.37 to 7, and we will use it as a predictor in the model.</p>
<p>We need to specify priors for all the parameters once again, but this time once for the <strong>intercept</strong> (the value when the predictors are at 0), and one for the <strong>effect of Conscientiousness</strong>. We will use the same priors as before for the intercept, and a <span class="math inline">\(Normal(0, 1)\)</span> for the effect of Conscientiousness. We use a symmetric priors for the effects as we don’t have any prior knowledge about the direction of the effect of Conscientiousness on Disinhibition.</p>
<p>We then reconstruct the parameters using the linear equation formula (<span class="math inline">\(y = intercept + \beta x\)</span>), and transform them back to their original scale before running the inference.</p>
<pre class="{julia}"><code>#| code-fold: false
#| output: false

@model function model_OrderedBeta(y, x)
    # Priors for the intercept
    μ_intercept ~ Normal(0, 1)
    ϕ_intercept ~ Normal(0, 1)
    k0_intercept ~ -Gamma(3, 3)
    k1_intercept ~ Gamma(3, 3)

    # Priors for the effect of x
    μ_x ~ Normal(0, 1)
    ϕ_x ~ Normal(0, 1)
    k0_x ~ Normal(0, 1)
    k1_x ~ Normal(0, 1)

    # Model
    for i in 1:length(y)
        μ = μ_intercept + μ_x * x[i]
        ϕ = ϕ_intercept + ϕ_x * x[i]
        k0 = k0_intercept + k0_x * x[i]
        k1 = k1_intercept + k1_x * x[i]

        y[i] ~ OrderedBeta(logistic(μ), exp(ϕ), logistic(k0), logistic(k1))
    end
end

# Refit
fit_OrderedBeta = model_OrderedBeta(df.Disinhibition2, df.Conscientiousness)
posteriors_OrderedBeta = sample(fit_OrderedBeta, NUTS(), 500)</code></pre>
<p>Let’s inspect the 95% CI to see if the effect of Conscientiousness is significant (i.e., if the CI does not include 0).</p>
<pre class="{julia}"><code>#| code-fold: false

# 95% CI
hpd(posteriors_OrderedBeta)</code></pre>
<p>Interestingly, we can see that Consciousness has a significant <strong>negative</strong> relationship with the mean of Disinhibition (<em>mu</em> <span class="math inline">\(\mu\)</span> parameter), but also a <strong>positive</strong> effect on <em>k0</em>. This suggests that participants with higher Conscientiousness scores are on average less Disinhibited, and are more likely to be “extremely” not Disinhibited (i.e., to respond 0).</p>
<pre class="{julia}"><code># Simulate models where conscientiousness is 7 and 1.37
m1 = model_OrderedBeta([(missing) for i in 1:length(df.Disinhibition2)], fill(7, length(df.Disinhibition2)))
m2 = model_OrderedBeta([(missing) for i in 1:length(df.Disinhibition2)], fill(1.37, length(df.Disinhibition2)))

# Generate predictions
pred1 = Array(predict(m1, posteriors_OrderedBeta))
pred2 = Array(predict(m2, posteriors_OrderedBeta))

# Plot
fig = Figure()
ax1 = Axis(fig[1, 1], title="High Conscientiousness", xlabel="Disinhibition", 
    ylabelvisible=false, yticklabelsvisible=false, yticksvisible=false)
ax1 = hist!(df.Disinhibition2, normalization=:pdf, color=:grey, bins=beta_bins(30))
for i in 1:size(pred1)[1]
    hist!(ax1, pred1[i, :], normalization=:pdf, bins=beta_bins(30), color=(:blue, 0.01))
end
ax2 = Axis(fig[1, 2], title="Low Conscientiousness", xlabel="Disinhibition", 
    ylabelvisible=false, yticklabelsvisible=false, yticksvisible=false)
ax2 = hist!(df.Disinhibition2, normalization=:pdf, color=:grey, bins=beta_bins(30))
for i in 1:size(pred2)[1]
    hist!(ax2, pred2[i, :], normalization=:pdf, bins=beta_bins(30), color=(:red, 0.01))
end
fig</code></pre>
<p>As we can see, <strong>Ordered Beta models</strong> are flexible and more appropriate to the type of data often observed in psychology. Moreover, by modelling all the parameters of the distribution, we managed to assess more subtle effects of the predictor on various aspects of the distribution of the dependent variable, possibly corresponding to various cognitive processes.</p>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-kubinec2023ordered" class="csl-entry" role="listitem">
Kubinec, Robert. 2023. <span>“Ordered Beta Regression: A Parsimonious, Well-Fitting Model for Continuous Data with Lower and Upper Bounds.”</span> <em>Political Analysis</em> 31 (4): 519–36.
</div>
<div id="ref-makowski2023novel" class="csl-entry" role="listitem">
Makowski, Dominique, An Shu Te, Stephanie Kirk, Ngoi Zi Liang, and SH Annabel Chen. 2023. <span>“A Novel Visual Illusion Paradigm Provides Evidence for a General Factor of Illusion Sensitivity and Personality Correlates.”</span> <em>Scientific Reports</em> 13 (1): 6594.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./2_predictors.html" class="pagination-link" aria-label="Predictors">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Predictors</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./3b_choices.html" class="pagination-link" aria-label="Binary Data and Choices">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Binary Data and Choices</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>