{"title":"Reaction Times","markdown":{"headingText":"Reaction Times","containsRefs":false,"markdown":"\n![](https://img.shields.io/badge/status-WIP-orange)\n\n## The Data\n\nFor this chapter, we will be using the data from @wagenmakers2008diffusion - Experiment 1 [also reanalyzed by @heathcote2012linear], that contains responses and response times for several participants in two conditions (where instructions emphasized either **speed** or **accuracy**).\nUsing the same procedure as the authors, we excluded all trials with uninterpretable response time, i.e., responses that are too fast (<180 ms) or too slow [>2 sec instead of >3 sec, see @theriault2024check for a discussion on outlier removal].\n\n```{julia}\n#| code-fold: false\n\nusing Downloads, CSV, DataFrames\nusing Turing, Distributions, SequentialSamplingModels\nusing GLMakie\n\ndf = CSV.read(Downloads.download(\"https://raw.githubusercontent.com/DominiqueMakowski/CognitiveModels/main/data/wagenmakers2008.csv\"), DataFrame)\n\n# Show 10 first rows\nfirst(df, 10)\n```\n\nIn the previous chapter, we modelled the error rate (the probability of making an error) using a logistic model, and observed that it was higher in the `\"Speed\"` condition. \nBut how about speed? We are going to first take interest in the RT of **Correct** answers only (as we can assume that errors are underpinned by a different *generative process*). \n\nAfter filtering out the errors, we create a new column, `Accuracy`, which is the \"binarization\" of the `Condition` column, and is equal to 1 when the condition is `\"Accuracy\"` and 0 when it is `\"Speed\"`.\n\n```{julia}\n#| output: false\n\ndf = df[df.Error .== 0, :]\ndf.Accuracy = df.Condition .== \"Accuracy\"\n```\n\n\n::: {.callout-tip title=\"Code Tip\"}\nNote the usage of *vectorization* `.==` as we want to compare each element of the `Condition` vector to the target `\"Accuracy\"`.\n:::\n\n```{julia}\nfunction plot_distribution(df, title=\"Empirical Distribution of Data from Wagenmakers et al. (2018)\")\n    fig = Figure()\n    ax = Axis(fig[1, 1], title=title,\n        xlabel=\"RT (s)\",\n        ylabel=\"Distribution\",\n        yticksvisible=false,\n        xticksvisible=false,\n        yticklabelsvisible=false)\n    Makie.density!(df[df.Condition .== \"Speed\", :RT], color=(\"#EF5350\", 0.7), label = \"Speed\")\n    Makie.density!(df[df.Condition .== \"Accuracy\", :RT], color=(\"#66BB6A\", 0.7), label = \"Accuracy\")\n    Makie.axislegend(\"Condition\"; position=:rt)\n    Makie.ylims!(ax, (0, nothing))\n    return fig\nend\n\nplot_distribution(df, \"Empirical Distribution of Data from Wagenmakers et al. (2018)\")\n```\n\n\n## Descriptive Models \n\n::: {.callout-note}\nNote until the last section, we will disregard the existence of multiple participants (which require the inclusion of random effects in the model).\nWe will treat the data as if it was a single participant at first to better understand the parameters, but will show how to add random effects at the end.\n:::\n\n### Gaussian (aka *Linear*) Model\n\nA linear model is the most common type of model. \nIt aims at predicting the **mean** $\\mu$ of the outcome variable using a **Normal** (aka *Gaussian*) distribution for the residuals.\nIn other words, it models the outcome $y$ as a Normal distribution with a mean $\\mu$ that is itself hte result of a linear function of the predictors $X$ and a variance $\\sigma$ that is constant across all values of the predictors.\nIt can be written as $y = Normal(\\mu, \\sigma)$, where $\\mu = intercept + slope * X$.\n\nIn order to fit a Linear Model for RTs, we need to set a prior on all these parameters, namely:\n- The variance $\\sigma$ (correspondong to the \"spread\" of RTs)\n- The mean $\\mu$ for the intercept (i.e., at the reference condition which is in our case `\"Speed\"`)\n- The effect of the condition (the slope).\n\n#### Model Specification\n\n```{julia}\n#| code-fold: false\n#| output: false\n\n@model function model_Gaussian(rt; condition=nothing)\n\n    # Set priors on variance, intercept and effect of condition\n    σ ~ truncated(Normal(0, 1); lower=0)\n\n    μ_intercept ~ truncated(Normal(0, 1); lower=0)\n    μ_condition ~ Normal(0, 0.5)\n\n    for i in 1:length(rt)\n        μ = μ_intercept + μ_condition * condition[i]\n        rt[i] ~ Normal(μ, σ)\n    end\nend\n\n\nmodel = model_Gaussian(df.RT; condition=df.Accuracy)\nchain_Gaussian = sample(model, NUTS(), 400)\n```\n\n```{julia}\n#| code-fold: false\n\n# Summary (95% CI)\nhpd(chain_Gaussian; alpha=0.05)\n```\n\n\nThe effect of Condition is significant, people are on average slower (higher RT) when condition is `\"Accuracy\"`.\nBut is our model good?\n\n#### Posterior Predictive Check\n\n```{julia}\n#| output: false\n\npred = predict(model_Gaussian([(missing) for i in 1:length(df.RT)], condition=df.Accuracy), chain_Gaussian)\npred = Array(pred)\n```\n\n```{julia}\n#| fig-width: 10\n#| fig-height: 7\n\nfig = plot_distribution(df, \"Predictions made by Gaussian (aka Linear) Model\")\nfor i in 1:length(chain_Gaussian)\n    lines!(Makie.KernelDensity.kde(pred[:, i]), color=ifelse(df.Accuracy[i] == 1, \"#388E3C\", \"#D32F2F\"), alpha=0.1)\nend\nfig\n```\n\n### Scaled Gaussian Model\n\nThe previous model, despite its poor fit to the data, suggests that the mean RT is higher for the `Accuracy` condition. But it seems like the distribution is also *wider* (response time is more variable). \nTypical linear model estimate only one value for sigma $\\sigma$ for the whole model, hence the requirement for **homoscedasticity**.\n\n::: {.callout-note}\n**Homoscedasticity**, or homogeneity of variances, is the assumption of similar variances accross different values of predictors. \nIt is important in linear models as only one value for sigma $\\sigma$ is estimated.\n:::\n\nIs it possible to set sigma $\\sigma$ as a parameter that would depend on the condition, in the same way as mu $\\mu$? In Julia, this is very simple.\n\nAll we need is to set sigma $\\sigma$ as the result of a linear function, such as $\\sigma = intercept + slope * condition$.\nThis means setting a prior on the intercept of sigma $\\sigma$ (in our case, the variance in the reference condition) and a prior on how much this variance changes for the other condition.\nThis change can, by definition, be positive or negative (i.e., the other condition can have either a biggger or a smaller variance), so the prior over the effect of condition should ideally allow for positive and negative values (e.g., `σ_condition ~ Normal(0, 0.1)`).\n\nBut this leads to an **important problem**.\n\n::: {.callout-important}\nThe combination of an intercept and a (possible negative) slope for sigma $\\sigma$ technically allows for negative variance values, which is impossible (distributions cannot have a negative variance).\nThis issue is one of the most important to address when setting up complex models for RTs.\n:::\n\nIndeed, even if we set a very narrow prior on the intercept of sigma $\\sigma$ to fix it at for instance **0.14**, and a narrow prior on the effect of condition, say $Normal(0, 0.001)$, an effect of condition of **-0.15** is still possible (albeit with very low probability). \nAnd such effect would lead to a sigma $\\sigma$ of **0.14 - 0.15 = -0.01**, which would lead to an error (and this will often happen as the sampling process does explore unlikely regions of the parameter space).\n\n\n#### Solution 1: Directional Effect of Condition\n\nOne possible (but not recommended) solution is to simply make it impossible for the effect of condition to be negative. \nThis can work in our case, because we know that the comparison condition is likely to have a higher variance than the reference condition (the intercept) - and if it wasn't the case, we could have changed the reference factor.\n\n\n```{julia}\n#| code-fold: false\n#| output: false\n\n@model function model_ScaledlGaussian1(rt; condition=nothing)\n\n    # Priors\n    μ_intercept ~ truncated(Normal(0, 1); lower=0)\n    μ_condition ~ Normal(0, 0.5)\n\n    σ_intercept ~ truncated(Normal(0, 1); lower=0)  # Same prior as previously\n    σ_condition ~ truncated(Normal(0, 0.1); lower=0)  # Enforce positivity\n\n    for i in 1:length(rt)\n        μ = μ_intercept + μ_condition * condition[i]\n        σ = σ_intercept + σ_condition * condition[i]\n        rt[i] ~ Normal(μ, σ)\n    end\nend\n\nmodel = model_ScaledlGaussian1(df.RT; condition=df.Accuracy)\nchain_ScaledGaussian = sample(model, NUTS(), 400)\n```\n\n```{julia}\n#| code-fold: false\n\n# Summary (95% CI)\nhpd(chain_ScaledGaussian; alpha=0.05)\n```\n\nWe can see that the effect of condition on sigma $\\sigma$ is significantly positive: the variance is higher in the `Accuracy` condition as compared to the `Speed` condition. \n\n#### Solution 2: Avoid Exploring Negative Variance Values\n\nThe other trick is to force the sampling algorithm to avoid exploring negative variance values (when sigma $\\sigma$ < 0).\nThis can be done by adding a conditional statement when sigma $\\sigma$ is negative to avoid trying this value and erroring, and instead returning an infinitely low model probability (`-Inf`) to push away the exploration of this impossible region.\n\n```{julia}\n#| code-fold: false\n#| output: false\n\n@model function model_ScaledlGaussian(rt; condition=nothing)\n\n    # Priors\n    μ_intercept ~ truncated(Normal(0, 1); lower=0)\n    μ_condition ~ Normal(0, 0.5)\n\n    σ_intercept ~ truncated(Normal(0, 1); lower=0)\n    σ_condition ~ Normal(0, 0.1)\n\n    for i in 1:length(rt)\n        μ = μ_intercept + μ_condition * condition[i]\n        σ = σ_intercept + σ_condition * condition[i]\n        if σ < 0  # Avoid negative variance values\n            Turing.@addlogprob! -Inf\n            return nothing\n        end\n        rt[i] ~ Normal(μ, σ)\n    end\nend\n\nmodel = model_ScaledlGaussian(df.RT; condition=df.Accuracy)\nchain_ScaledGaussian = sample(model, NUTS(), 400)\n```\n\n```{julia}\n#| code-fold: false\n\nhpd(chain_ScaledGaussian; alpha=0.05)\n```\n\n```{julia}\npred = predict(model_ScaledlGaussian([(missing) for i in 1:length(df.RT)], condition=df.Accuracy), chain_ScaledGaussian)\npred = Array(pred)\n\nfig = plot_distribution(df, \"Predictions made by Scaled Gaussian Model\")\nfor i in 1:length(chain_ScaledGaussian)\n    lines!(Makie.KernelDensity.kde(pred[:, i]), color=ifelse(df.Accuracy[i] == 1, \"#388E3C\", \"#D32F2F\"), alpha=0.1)\nend\nfig\n```\n\n\n\n<!-- #### Solution 3: Express Variance on the Exponential Scale\nSee https://github.com/itsdfish/SequentialSamplingModels.jl/issues/78#issuecomment-2211702253 \nIS THAT RIGHT? -->\n\nAlthough relaxing the homoscedasticity assumption is a good step forward, allowing us to make **richer conclusions** and better capturing the data.\nDespite that, the Gaussian model stil seem to be a poor fit to the data.\n\n### The Problem with Linear Models\n\nReaction time (RTs) have been traditionally modeled using traditional linear models and their derived statistical tests such as *t*-test and ANOVAs. Importantly, linear models - by definition - will try to predict the *mean* of the outcome variable by estimating the \"best fitting\" *Normal* distribution. In the context of reaction times (RTs), this is not ideal, as RTs typically exhibit a non-normal distribution, skewed towards the left with a long tail towards the right. This means that the parameters of a Normal distribution (mean $\\mu$ and standard deviation $\\sigma$) are not good descriptors of the data.\n\n![](media/rt_normal.gif)\n\n> Linear models try to find the best fitting Normal distribution for the data. However, for reaction times, even the best fitting Normal distribution (in red) does not capture well the actual data (in grey).\n\nA popular mitigation method to account for the non-normality of RTs is to transform the data, using for instance the popular *log-transform*. \nHowever, this practice should be avoided as it leads to various issues, including loss of power and distorted results interpretation [@lo2015transform; @schramm2019reaction].\nInstead, rather than applying arbitrary data transformation, it would be better to swap the Normal distribution used by the model for a more appropriate one that can better capture the characteristics of a RT distribution.\n\n\n### Shifted LogNormal Model\n\nOne of the obvious candidate alternative to the log-transformation would be to use a model with a Log-transformed Normal distribution.\n\nNew parameter, $\\tau$ (Tau for delay), which corresponds to the \"starting time\". We need to set a prior for this parameter, which is usually truncated between 0 and the minimum RT of the data (the logic being that the minimum delay for response must be lower than the faster response actually observed).\n\n```{julia}\nxaxis = range(0, 1, 1000)\nlines(xaxis, pdf.(Gamma(1.1, 11), xaxis))\n```\n\n#### Model\n\n```{julia}\n#| code-fold: false\n\n@model function model_lognormal(rt; min_rt=minimum(df.RT), condition=nothing)\n\n    # Priors \n    σ ~ truncated(Normal(0, 0.5); lower=0)\n    τ ~ truncated(Gamma(1.1, 11); upper=min_rt)\n\n    μ_intercept ~ Normal(0, 2)\n    μ_condition ~ Normal(0, 0.5)\n\n    for i in 1:length(rt)\n        μ = μ_intercept + μ_condition * condition[i]\n        rt[i] ~ ShiftedLogNormal(μ, σ, τ)\n    end\nend\n\nmodel = model_lognormal(df.RT; condition=df.Accuracy)\nchain_lognormal = sample(model, NUTS(), 400)\n\n# Summary (95% CI)\nquantile(chain_lognormal; q=[0.025, 0.975])\n```\n\n```{julia}\n#| output: false\n\npred = predict(model_lognormal([(missing) for i in 1:length(df.RT)]; condition=df.Accuracy), chain_lognormal)\npred = Array(pred)\n```\n\n```{julia}\n#| fig-width: 10\n#| fig-height: 7\n\nfig = plot_distribution(df, \"Predictions made by Shifted LogNormal Model\")\nfor i in 1:length(chain_lognormal)\n    lines!(Makie.KernelDensity.kde(pred[:, i]), color=ifelse(df.Accuracy[i] == 1, \"#388E3C\", \"#D32F2F\"), alpha=0.1)\nend\nfig\n```\n\n#### More Conditional Parameters\n\n```{julia}\nxaxis = range(-6, 2, 1000)\nfig = Figure()\nax = Axis(fig[1, 1])\nlines!(xaxis, pdf.(-Weibull(2, 2.5)+1, xaxis); color=\"red\")\nlines!(xaxis, pdf.(-Weibull(2.5, 2)+1, xaxis); color=\"orange\")\nlines!(xaxis, pdf.(-Weibull(2.5, 2.5)+1, xaxis); color=\"blue\")\nlines!(xaxis, pdf.(-Weibull(2.5, 3)+1, xaxis); color=\"green\")\nax2 = Axis(fig[1, 2])\nlines!(exp.(xaxis), pdf.(-Weibull(2, 2.5)+1, xaxis); color=\"red\")\nlines!(exp.(xaxis), pdf.(-Weibull(2.5, 2)+1, xaxis); color=\"orange\")\nlines!(exp.(xaxis), pdf.(-Weibull(2.5, 2.5)+1, xaxis); color=\"blue\")\nlines!(exp.(xaxis), pdf.(-Weibull(2.5, 3)+1, xaxis); color=\"green\")\nfig\n```\n\n```{julia}\n#| code-fold: false\n\n@model function model_lognormal2(rt; min_rt=minimum(df.RT), condition=nothing)\n\n    # Priors \n    τ ~ truncated(Gamma(1.1, 11); upper=min_rt)\n\n    μ_intercept ~ Normal(0, 2)\n    μ_condition ~ Normal(0, 0.5)\n\n    σ_intercept ~ -Weibull(2.5, 3) + 1\n    σ_condition ~ Normal(0, 0.01)\n\n    for i in 1:length(rt)\n        μ = μ_intercept + μ_condition * condition[i]\n        σ = σ_intercept + σ_condition * condition[i]\n        rt[i] ~ ShiftedLogNormal(μ, exp(σ), τ)\n    end\nend\n\nmodel = model_lognormal2(df.RT; condition=df.Accuracy)\nchain_lognormal2 = sample(model, NUTS(), 400)\n\n# Summary (95% CI)\nquantile(chain_lognormal2; q=[0.025, 0.975])\n```\n\n```{julia}\n#| output: false\n\npred = predict(model_lognormal2([(missing) for i in 1:length(df.RT)]; condition=df.Accuracy), chain_lognormal2)\npred = Array(pred)\n```\n\n```{julia}\n#| fig-width: 10\n#| fig-height: 7\n\nfig = plot_distribution(df, \"Predictions made by Shifted LogNormal Model\")\nfor i in 1:length(chain_lognormal2)\n    lines!(Makie.KernelDensity.kde(pred[:, i]), color=ifelse(df.Accuracy[i] == 1, \"#388E3C\", \"#D32F2F\"), alpha=0.1)\nend\nfig\n```\n\n\n### ExGaussian Model\n\n\n- [**Ex-Gaussian models in R: A Tutorial**](https://dominiquemakowski.github.io/easyRT/articles/exgaussian.html)\n\n### Wald Model\n\nMoe from statistical models that *describe* to models that *generate* RT-like data.\n\n## Generative Models (DDM)\n\nUse DDM as a case study to introduce generative models\n\n- [**Drift Diffusion Model (DDM) in R: A Tutorial**](https://dominiquemakowski.github.io/easyRT/articles/ddm.html)\n\n## Other Models (LBA, LNR)\n\n## Including Random Effects\n\nTODO.\n\n## Additional Resources\n\n- [**Lindelov's overview of RT models**](https://lindeloev.github.io/shiny-rt/): An absolute must-read.\n- [**De Boeck & Jeon (2019)**](https://www.frontiersin.org/articles/10.3389/fpsyg.2019.00102/full): A paper providing an overview of RT models.\n- [https://github.com/vasishth/bayescogsci](https://github.com/vasishth/bayescogsci)\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"execute":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"4_rt.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.549","bibliography":["references.bib"],"theme":"pulse","number-depth":3},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}