{
  "hash": "70d4242990940a8e666bf48fbbd0f7fb",
  "result": {
    "engine": "jupyter",
    "markdown": "# Binary Data and Choices\n\n![](https://img.shields.io/badge/status-good_for_contributing-blue)\n\n## The Data\n\nFor this chapter, we will be using the data from @wagenmakers2008diffusion - Experiment 1 [also reanalyzed by @heathcote2012linear], that contains responses and response times for several participants in two conditions (where instructions emphasized either **speed** or **accuracy**).\nUsing the same procedure as the authors, we excluded all trials with uninterpretable response time, i.e., responses that are too fast (<180 ms) or too slow [>2 sec instead of >3 sec, see @theriault2024check for a discussion on outlier removal].\n\nIn this chapter, we will focus on the \"amount\" of **errors** between the two conditions (response times will be the focus of the next chapter).\n\n::: {#27db495d .cell execution_count=2}\n``` {.julia .cell-code code-fold=\"false\"}\nusing Downloads, CSV, DataFrames, Random\nusing Turing, Distributions, StatsFuns, SubjectiveScalesModels\nusing GLMakie\n\nRandom.seed!(123)  # For reproducibility\n\ndf = CSV.read(Downloads.download(\"https://raw.githubusercontent.com/DominiqueMakowski/CognitiveModels/main/data/wagenmakers2008.csv\"), DataFrame)\n\n# Show 10 first rows\nfirst(df, 10)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div><div style = \"float: left;\"><span>10×5 DataFrame</span></div><div style = \"clear: both;\"></div></div><div class = \"data-frame\" style = \"overflow-x: scroll;\"><table class = \"data-frame\" style = \"margin-bottom: 6px;\"><thead><tr class = \"header\"><th class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">Row</th><th style = \"text-align: left;\">Participant</th><th style = \"text-align: left;\">Condition</th><th style = \"text-align: left;\">RT</th><th style = \"text-align: left;\">Error</th><th style = \"text-align: left;\">Frequency</th></tr><tr class = \"subheader headerLastRow\"><th class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\"></th><th title = \"Int64\" style = \"text-align: left;\">Int64</th><th title = \"String15\" style = \"text-align: left;\">String15</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Bool\" style = \"text-align: left;\">Bool</th><th title = \"String15\" style = \"text-align: left;\">String15</th></tr></thead><tbody><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">1</td><td style = \"text-align: right;\">1</td><td style = \"text-align: left;\">Speed</td><td style = \"text-align: right;\">0.7</td><td style = \"text-align: right;\">false</td><td style = \"text-align: left;\">Low</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">2</td><td style = \"text-align: right;\">1</td><td style = \"text-align: left;\">Speed</td><td style = \"text-align: right;\">0.392</td><td style = \"text-align: right;\">true</td><td style = \"text-align: left;\">Very Low</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">3</td><td style = \"text-align: right;\">1</td><td style = \"text-align: left;\">Speed</td><td style = \"text-align: right;\">0.46</td><td style = \"text-align: right;\">false</td><td style = \"text-align: left;\">Very Low</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">4</td><td style = \"text-align: right;\">1</td><td style = \"text-align: left;\">Speed</td><td style = \"text-align: right;\">0.455</td><td style = \"text-align: right;\">false</td><td style = \"text-align: left;\">Very Low</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">5</td><td style = \"text-align: right;\">1</td><td style = \"text-align: left;\">Speed</td><td style = \"text-align: right;\">0.505</td><td style = \"text-align: right;\">true</td><td style = \"text-align: left;\">Low</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">6</td><td style = \"text-align: right;\">1</td><td style = \"text-align: left;\">Speed</td><td style = \"text-align: right;\">0.773</td><td style = \"text-align: right;\">false</td><td style = \"text-align: left;\">High</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">7</td><td style = \"text-align: right;\">1</td><td style = \"text-align: left;\">Speed</td><td style = \"text-align: right;\">0.39</td><td style = \"text-align: right;\">false</td><td style = \"text-align: left;\">High</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">8</td><td style = \"text-align: right;\">1</td><td style = \"text-align: left;\">Speed</td><td style = \"text-align: right;\">0.587</td><td style = \"text-align: right;\">true</td><td style = \"text-align: left;\">Low</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">9</td><td style = \"text-align: right;\">1</td><td style = \"text-align: left;\">Speed</td><td style = \"text-align: right;\">0.603</td><td style = \"text-align: right;\">false</td><td style = \"text-align: left;\">Low</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">10</td><td style = \"text-align: right;\">1</td><td style = \"text-align: left;\">Speed</td><td style = \"text-align: right;\">0.435</td><td style = \"text-align: right;\">false</td><td style = \"text-align: left;\">High</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\nLet us first compute the average number of errors for each condition.\n\n::: {#8ef016c2 .cell execution_count=3}\n``` {.julia .cell-code code-fold=\"false\"}\ncombine(groupby(df, :Condition), :Error => mean)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div><div style = \"float: left;\"><span>2×2 DataFrame</span></div><div style = \"clear: both;\"></div></div><div class = \"data-frame\" style = \"overflow-x: scroll;\"><table class = \"data-frame\" style = \"margin-bottom: 6px;\"><thead><tr class = \"header\"><th class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">Row</th><th style = \"text-align: left;\">Condition</th><th style = \"text-align: left;\">Error_mean</th></tr><tr class = \"subheader headerLastRow\"><th class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\"></th><th title = \"String15\" style = \"text-align: left;\">String15</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th></tr></thead><tbody><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">1</td><td style = \"text-align: left;\">Speed</td><td style = \"text-align: right;\">0.110407</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">2</td><td style = \"text-align: left;\">Accuracy</td><td style = \"text-align: right;\">0.0451463</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n::: {#63ca47a6 .cell execution_count=4}\n``` {.julia .cell-code}\ndat = combine(groupby(df, :Condition), :Error => mean)\n\nfig = Figure()\nax = Axis(fig[1, 1], ylabel=\"Average error rate\", xticks =([0, 1], [\"Speed\", \"Accuracy\"]))\nbarplot!(ax, [0], [dat.Error_mean[1]], label=\"Speed\", color=:red)\nbarplot!(ax, [1], [dat.Error_mean[2]], label=\"Accuracy\", color=:green)\naxislegend()\nfig\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<img width=600 height=450 style='object-fit: contain; height: auto;' src=\"data:image/png;base64, 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IiKq2wSsIIRwdnZOT09v27YtqqSnp7u7u9vY2ICIiKjOE7CCEGLMmDHTpk27efMmgPLy8g8//HDx4sXTp08XQoCIiKjOE7BObGysSqVavnz5pUuXDh486OfnN2vWrJEjR4KIiKg+ELDO+fPnn3nmmUGDBhUUFJjNZgcHh+zs7IyMjCeeeAJERER1nsDjKiwsBDBhwoSZM2fa2toKIQCUlpamp6cvWrRo3759ICIiqvMEHlf//v0vXbpUVFQUExODaoxGY7du3UBERFQfCDyuuLg4APPmzZswYYKtrS2qCQoKAhERUX0g8Lg6d+4MoLKy0sfHJyAgAFXOnj377bff9u/fH0RERHWegHU6duy4adOmPXv2oEpubm5ycnK/fv1kMhmIiIjqNgHrvPPOO2vXrvX39z958mRYWFhlZeWNGzfmz58vk8lARERU5wlYwWAw7Nu3b9GiRf3793/hhRdiY2O7desWFxd39epVEBER1QcCVjCbzWVlZX5+fnK5vGnTphcvXuzVq9egQYPGjh07YcIEpVIJIiKiuk3ACkql0t3d/dixYy1atNDr9QcOHABgNBoLCwsrKiqUSiWIiIjqNgEryOXy0aNHv/766/n5+YMHD541a9aoUaMuXLjQrl07W1tbEBER1XkC1hk6dGhwcHB2dnbz5s0//fTTjRs3durUacKECSAiIqoPBKxQXl4+fvz4Ll26DBw4EEBPCxAREdUfAlZQKBRXr149f/48iIiI6icBKwghZs+enZCQsGjRopCQELlcjioREREgIiKq8wSsM2fOnPPnz589e1Ymk6FKcHBwREQEiIiI6jwB66xbtw5ERET1loB1HBwcQEREVG8JEBERSZgAERGRhAlYJzs7W6lUuru7g4iIqB4SsEJZWVm3bt3efPPN2NhYEBER1UMCVlCr1YMGDdqxY0e/fv0cHR1BRERU3whY5/bt246Ojk899VTTpk1RxdbWdu3atSAiIqrzBKzj4eFRWVnp7e2NahQKBYiIiOoDAevMmjULgMlkKi4uBmBnZyeXy0FERFRPCFjHbDavXbt2zZo1V65cMZlMfn5+I0aMGDp0KIiIiOoDAessX7585syZo0aNeu2118xm84kTJ6ZMmVJaWjpmzBgQERHVeQJWMBqNX375ZWJi4qhRo2ARHR3t5+e3atWqESNGCCFARERUtwlYwWg05ufn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AxH9I5QZy+6V3VtxegWI/gqpN1NRJfVmKqqMbjO6zFimVClRuwSsM3/+/NOnT69bt27VqlUABg8ePH369Llz577//vsgIiKq8wSsUF5evnPnzrlz50ZGRq5atQpA27Ztp02b9sYbb5SXl9vY2ICI/hHySvNAVMPySvPwdxCwgtlsNhqN9vb2qMbGxsZgMJhMJhAREdV5AlZQq9UdO3ZcvHixn58fLG7duvXZZ5+FhYVpNBoQ0T9FVkEWiGpYVkEW/g4C1omLixszZkx4eLi7u/vly5enTZvm4+OzcuVKEBER1QcC1vHx8dm6dWtKSkp6enplZaVer4+IiLC3twcREVF9IGCdmJiYbhZdu3YFERFRfSNgHRcXl7lz586aNatXr16DBg168sknbWxsQET/LBl3M0BUwzLuZuDvIGCdxYsX37t379ixY1u2bBk9erSrq+vzzz/ft2/fZs2agYiIqM4TsJpOp+ttcfv27SNHjnz00UeHDx/esWMHiIiI6jwBq5WXl587d27Pnj27d+++du1acHBw//79QUREVB8IWGf27Nm7du26dOlS69atX3jhhW7duvn7+8tkMhAREdUHAtZJS0uLjo7u3bt3YGCgEAIWRqNRCAEiIqI6T8A669evVyqVsDCZTL/88suePXuOHj26ZcsWEBER1XkC1lEqlQCuXbuWlJS0efPmY8eOaTSayMhIEBER1QcCVrh169bhw4c3bdqUkpJiMBhCQkIWL14cFRXl7e0NIiKi+kDgsezateubb745ePBgSUlJeHh4YmJiQUHBiRMnYmNjQUREVH8IPJbk5ORvv/12ypQp3bt3b9asmUwmW7hwIYiIiOobgcfSoEEDDw+PuLi4jRs39u/fv1evXiAiIqqHBB7L5MmTx48f/+OPP27ZsmXlypXz5s0LCwvTarUXLlzw9/eXyWQgIiKqDwQel0qlam8RFxf3/fffb9q06cCBA+Hh4R07dhwwYMCwYcNARERU5wlYzd7evptFTk5OcnLy5s2b16xZM2zYMBAREdV5An8dNze3gRbXrl0DERFRfSBQA3x9fUFERFQfCBAREUmYABERkYQJEBERSZgAERGRhAkQERFJmAAREZGECRAREUmYABERkYQJEBERSZgAERGRhAkQERFJmAAREZGECRAREUmYABERkYQJEBERSZgAERGRhAkQERFJmAAREZGECRAREUmYABERkYQJEBERSZgAERGRhAkQERFJmAAREZGECRAREUmYABERkYQJEBERSZgAERGRhAkQERFJmAAREZGECRAREUmYABERkYQJEBERSZgAERGRhAkQERFJmAAREZGECRAREUmYABERkYQJEBERSZgAERGRhAkQERFJmAAREZGECRAREUmYABERkYQJEBERSZgAERGRhAkQERFJmAAREZGECRAREUmYABERkYQJEBERSZgAERGRhAkQERFJmAAREZGECRAREUmYABERkYQJEBERSZgAERGRhAkQERFJmAAREZGECRAREUmYABERkYQJEBERSZgAERGRhAkQERFJmAAREZGECRAREUmYABERkYQJEBERSZgAERGRhAkQERFJmAAREZGECRAREUmYABERkYQJEBERSZgAERGRhAkQERFJmAAREZGECRAREUmYABERkYQJEBERSZgAERGRhAkQERFJmAAREZGECRAREUmYABERkYQJEBERSZgAERGRhAkQERFJmAAREZGECRAREUmYABERkYQJEBERSZgAERGRhAkQERFJmAAREZGECRAREUmYABERkYQJEBERSZgAERGRhAkQERFJmAAREZGECRAREUmYABERkYQJEBERSZgAERGRhAkQERFJmAAREZGECRAREUmYABERkYQJEBERSZgAERGRhAnQ/6TXIzUVRDVKr0cdpnfVp95MBVFN0rvq8XcQICIikjABIiIiCRP4mxgMBqVSKZPJ8Agmk8loNKpUKjyosrLSZDIplUoQERFZTaDWpaWlzZkzJz09vWHDhhMnTuzduzcesn79+s8++yw/Pz84OHjWrFlNmzYFUFFRsWjRok2bNhmNxq5du86YMcPBwQG1wMcHqakgqlE+PqjDfBx9Um+mgqgm+Tj64O8gULvy8/NHjRrVunXrZcuWHTlyZNSoUbt3727Tpg2qSUpKmjhx4syZMwMDA5csWfLKK69s375drVYvXbr0008/nT9/vkajmTVrVnl5+cKFC0FERGQFgdq1d+/e3NzcxMREDw+PDh06HDlyZP369W3atEE1K1eu7NGjx7hx4wB4enpGRkYeP368Xbt2q1evnjhx4r/+9S8ABoPhtddemzJlSsOGDVHTnJ1BVNOcnVGHOWucQVTDnDXO+DsI1K7jx48HBgZ6eHgAEEJEREQkJyebzWaZ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19PS0lQqldFoLCwsdHJyAnD9+vW0tLTw8HBUU1RUZDQa8ZD33nsvJSVl8eLFzZs3t7W1jYyMBKBSqWxtbfPz82FhMBj27dvXqFGj1q1bd+jQYffu3ZcvX46OjtZqtaAaIED0CGFhYXfv3v3888/Hjh1rZ2dnNpt/+eWXkydPDh48GBZfffVVp06dbGxskpKSfvrpp4SEhAYNGuTk5KSkpDz77LMAtm/fnpCQ8O233z711FOvvfbalStXAgMDTSbTkiVLzpw5s3379qCgoHXr1kVERNjY2Pzwww+nT59++umnQVS7Tp8+ff78+Xnz5j355JOwKCgo8Pb23rZt2/Tp011cXLZt2zZ+/HgAe/fuXbJkye7du11cXLZt2zZ+/HgAe/fuXbJkyXfffSeTybKzs2Gxe/fu4uJiPOTSpUvt2rXr0KEDgHPnzv36668AXFxcQkNDv/7666ioKJVKderUqdGjRyclJQF47rnnZs+efe/evbi4OFDNECB6hMDAwDlz5rzzzjurV69u0KBBRUVFZmZmeHj4q6++ajKZ5HJ5SUlJz549XVxcjh49+uKLL0ZERMjl8smTJ7/88str1641m83ff/99QkKCq6trr169tm3bFh0dHR4enpube+HChdWrVysUijfffDM2NjY6OtrX1zclJeWll14CUa3bunVr48aN27ZtiyqOjo7du3ffs2fPzJkz33rrralTpyYnJyuVymPHjs2ePdvHx+ett96aOnVqcnKyUqk8duzY7Nmz7e3tu3btumDBgszMzFILT09PPKR79+5xcXEFBQUAfvrpp9DQ0C+++MLb23v69OnDhg3r2bOnl5fXd99998ILL7Rq1QpAREREfn6+v79/69atQTVDgOjRXnrppW7duqWmpt68edPBwSEwMDA0NFShUOTm5gKYNm3apUuXrl69OmrUqK5du8rlcgBTpkzp2LHjqVOnFArFtGnT2rRpA0CpVH722WcHDx786aefXFxcOnfu3KRJEwCRkZG7d+/ev39/aWnp8OHDCwoKhBAgql2dOnV66qmnbG1tUc0LL7zQpUuXO3fuDB06tGXLlkePHjWbzW+88Ubbtm0BDB06tGXLlkePHjWbzW+88Ubbtm0BxMXFtWnT5ty5c40bN+7Zs+fp06d1Op1arf7qq6+cnZ1hMXr0aD8/v9OnT7u7uyckJAD4/vvvvby8AgMD9+/fn5SUlJubO3To0KioKFjodDpvb+8BAwYIIUA1Q4Dov2psgf9ELpcPGDAADwm3wIOUSmUPCzwo0AJEf58+ffrgIe3bt0eVYAs8KNgC1SgUij4WsIiMjIRFVFQUqomyQJXnn38eFo0aNRo5ciSqKSkpOX78+JUrV3r27AmqMQJERFQnRUdHX7x48cUXX2zSpAmoxggQ/XkqlerTTz+1s7MDEdWYt956q7Ky8qmnngLVJAGiP8/e3r5fv34gopoUGRkJqnkCREREEiZAREQkYQJEREQSJkBERCRhAkRERBImQEREJGECREREEiZAREQkYQJEREQSJkBERCRhAkRERBImQEREJGECREREEvb/Ae36vv/yu4xRAAAAAElFTkSuQmCC\"/>\n```\n:::\n:::\n\n\nLet us then format the data for the model by transforming the `Condition` column into a binary variable (0 for `Speed` and 1 for `Accuracy`).\nThis means that the intercept of the model will represent the error rate in the `Speed` condition, and we will be able to estimate the effect of the `Accuracy` condition on the error rate.\n\n::: {#faf993ed .cell execution_count=5}\n``` {.julia .cell-code code-fold=\"false\"}\ndf.Accuracy = ifelse.(df.Condition .== \"Accuracy\", 1, 0)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n10369-element Vector{Int64}:\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n ⋮\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n```\n:::\n:::\n\n\nOur hypothesis is that the `Accuracy` condition will **decrease** the error rate compared to the `Speed` condition.\n\n## Logistic models for Binary Data\n\nThe statistical models that we use aim at uncovering the **parameters of the distribution** that best predicts the data.\nIn a standard linear regression, this means estimating the mean *mu* $\\mu$ (which often is expressed as a function of another variable, such as the `Condition`) and the standard deviation *sigma* $\\sigma$ of the normal distribution that best fits the data.\n\nHowever, when the dependent variable is binary (e.g., 0 or 1), we cannot use a normal distribution, as it would predict values outside the [0, 1] range.\nWe saw in the previous chapter how to model \"probabilities\" (values between 0 and 1) using $Beta$ distributions, but in this part we will use another distribution: the **Bernoulli** distribution.\nThe Bernoulli distribution is a distribution that generates only zeros and ones (or True and False) with a single parameter: the probability of success *p*.\n\nIn the data above, we saw that the error rate (the proportion - or the \"probability\" - of errors) in the `Speed` condition was `0.11` (11%).\nThis would potentially translate into a distribution $Bernoulli(0.11)$.\nIn our model, we will estimate this probability at this reference condition (*aka* the **intercept**), as well as the effect of the `Accuracy` condition (which, in this case, we expect to be **negative**, as that condition seems to **lower** the error rate).\nWe will set **priors** for these two parameters (intercept and the effect of accuracy) that will get explored by the sampling algorithm.\n\nBut here is the **catch**.\nImagine the sampling algorithm picks a value of $0.11$ for the intercept (close to the true value) and then decides to explore a value of $-0.20$.\nThis would lead to a tentative value of $0.11 - 0.20 = -0.09$... but this parameter is **impossible** (the *p* parameter of the $Bernouilli$ distribution must be betwen 0 and 1).\n\nSimilarly to the previous chapter, we will avoid these issues by expressing our probability *p* on the **logit scale**. \nThis way, the effect of `Accuracy` will be expressed as a **log-odds** (i.e., the log of the odds ratio), which can take any value between $-\\infty$ and $+\\infty$.\nWe will then convert this log-odds back to a probability using the **logistic function** (the \"inverse\" of the logit transformation) which maps any value to the [0, 1] range.\n\n::: {#0475c9ba .cell execution_count=6}\n``` {.julia .cell-code code-fold=\"false\"}\n@model function model_logistic(y; condition=df.Accuracy)\n    # Priors\n    p_intercept ~ Normal(0, 1)\n    p_condition ~ Normal(0, 1)\n    \n    # Likelihood\n    for i in 1:length(y)\n        # Linear model equation\n        p = p_intercept + p_condition * condition[i]\n        \n        # Inference\n        y[i] ~ BernoulliLogit(p)\n    end\nend\n\nfit_logistic = model_logistic(df.Error, condition=df.Accuracy)\nposteriors_logistic = sample(fit_logistic, NUTS(), 500)\n```\n:::\n\n\n::: {.callout-tip title=\"Code Tip\"}\nNote the use of `BernoulliLogit(p)`, which is equivalent to `Bernoulli(logistic(p))` but more efficient. \n:::\n\n::: {#35729348 .cell execution_count=7}\n``` {.julia .cell-code code-fold=\"false\"}\n# 95% CI\nhpd(posteriors_logistic)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>HPD\n <span class=\"ansi-bold\">  parameters </span> <span class=\"ansi-bold\">   lower </span> <span class=\"ansi-bold\">   upper </span>\n <span class=\"ansi-bright-black-fg\">      Symbol </span> <span class=\"ansi-bright-black-fg\"> Float64 </span> <span class=\"ansi-bright-black-fg\"> Float64 </span>\n  p_intercept   -2.1812   -2.0035\n  p_condition   -1.0957   -0.8047\n</pre>\n```\n:::\n\n:::\n:::\n\n\nIn order to visualize the results, we are going to errors and then overlay the predicted error rates for each condition for each posterior draw.\n\n::: {#6a7ddf32 .cell execution_count=8}\n``` {.julia .cell-code}\npred = predict(model_logistic(fill(missing, length(df.Error)), condition=df.Accuracy), posteriors_logistic)\npred = Array(pred)\n\nfor i in 1:length(posteriors_logistic)\n    mean_speed = mean(pred[i, :][df.Accuracy .== 0])\n    mean_accuracy = mean(pred[i, :][df.Accuracy .== 1])\n    lines!([0, 1], [mean_speed, mean_accuracy], color=(:black, 0.1), linewidth=1)\nend\n\nfig\n```\n:::\n\n\nThe model appears to successfully recover the average error rates for each condition.\n\n\n## Mixed Logistic models\n\nHowever, this model overlooks the fact that the data has **repeated measures**. In other words, each individual observation is nested within an overarching cluster that is a \"participant\".\nTaking into account this structure can lead to more accurate estimates of the fixed effects (the intercept and the effect of `Accuracy`), as well as a quantification of the variability between participants.\n\nSetting a mixed model in Turing requires, for each \"random\" effect (that can be added to any of the \"fixed\" parameters):\n- A prior for the **standard deviation** of the random effects (i.e., the variability between participants). This will determine how much each participant are assumed (and allowed) to deviate from the average effect.\n- A series of priors for each participant. These priors are typically centered at 0 (i.e., no deviation from the average effect) and have a standard deviation equal to the one defined above.\n\n::: {#3bbd4446 .cell execution_count=9}\n``` {.julia .cell-code code-fold=\"false\"}\n@model function model_logistic(y; condition=df.Accuracy, participant=df.Participant)\n    # Priors for  fixed effects\n    p_intercept_fixed ~ Normal(0, 1)\n    p_condition_fixed ~ Normal(0, 1)\n\n    # Priors for the SD of the random effects \n    p_intercept_participant_sd ~ truncated(Normal(0, 0.5); lower=0)\n    p_condition_participant_sd ~ truncated(Normal(0, 0.5); lower=0)\n\n    # Priors for each participant\n    p_intercept_participant ~ filldist(Normal(0, p_intercept_participant_sd), length(unique(participant)))\n    p_condition_participant ~ filldist(Normal(0, p_condition_participant_sd), length(unique(participant)))\n    \n    # Likelihood\n    for i in 1:length(y)\n        # Random components\n        p_intercept = p_intercept_fixed + p_intercept_participant[participant[i]]\n        p_condition = p_condition_fixed + p_condition_participant[participant[i]]\n\n        # Linear model equation\n        p = p_intercept + p_condition * condition[i]\n        \n        # Inference\n        y[i] ~ BernoulliLogit(p)\n    end\nend\n\nfit_logistic = model_logistic(df.Error, condition=df.Accuracy, participant=df.Participant)\nposteriors_logistic = sample(fit_logistic, NUTS(), 500)\n# using MicroCanonicalHMC\n# posteriors_logistic = sample(fit_logistic, externalsampler(MCHMC(1000, 0.001)), 500)\n```\n:::\n\n\nUnfortunately, mixed models are very slow in Julia for now.\n\n## Choice-Confidence (Choco) Models\n\nSee [here](https://dominiquemakowski.github.io/SubjectiveScalesModels.jl/dev/Choco/).\nTODO.\n\n\n\n\n\n<!-- \n## Real Data Example\n\n### Data Preprocessing \n\n\n```@example choco2\nusing DataFrames, CSV, Downloads\nusing Random\nusing Turing\nusing CairoMakie\nusing StatsFuns: logistic\nusing SubjectiveScalesModels\n```\n\n```@example choco2\nRandom.seed!(123)\n\ndf = CSV.read(Downloads.download(\"https://raw.githubusercontent.com/RealityBending/FakeFace/main/data/data.csv\"), DataFrame)\ndf = df[:, [:Participant, :Stimulus, :Real, :Attractive]]\n\nhist(df.Real, bins=30,  normalization=:pdf, color=:darkred)\n```\n\n",
    "supporting": [
      "3b_choices_files\\figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}